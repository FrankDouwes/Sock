package sock {		import flash.desktop.NativeApplication;	import flash.display.MovieClip;	import flash.display.NativeWindow;	import flash.display.Sprite;	import flash.errors.IOError;	import flash.events.Event;	import flash.events.IOErrorEvent;	import flash.events.ProgressEvent;	import flash.events.SecurityErrorEvent;	import flash.events.ServerSocketConnectEvent;	import flash.events.TimerEvent;	import flash.net.NetworkInfo;	import flash.net.NetworkInterface;	import flash.net.ServerSocket;	import flash.net.Socket;	import flash.utils.ByteArray;	import flash.utils.CompressionAlgorithm;	import flash.utils.Timer;	import flash.utils.getQualifiedClassName;	import flash.utils.setTimeout;		import events.CommEvent;	import events.LogEvent;		import sock.widget.Widget;
		/**	 * <p>The main Sock class (where all the magic happens), sets up a socket server or client, 	 * takes care of the connection(s) and error handling. Including a auto reconnect routine (both client and server) 	 * a settings sync function (across clients) and includes all sorts of communicative and save functions,	 * the Sock instance can be initialized to be either a server or a client.</p>	 * 	 * <p>Everything Sock does is invisible, it sends and receives strings/objects, parses them and triggers events,	 * to make this process visible (and easier to work with) a widget is included. The widget is a floating window with	 * a log displaying most incoming and outgoing data, and if/how the data is parsed.</p>	 * 	 * <p>Sock also includes a settings class that deals with saving/loading settings from/to an XML file,	 * when setup correctly data is never lost! and always available for the app that needs it. </p>	 * 	 * <h2>Clients and the server:</h2>	 * 	 * <ul>	 * <li>clients automatically reconnect to the server when the connection is lost</li>	 * <li>clients can send data to the server or to other clients (via the server)</li>	 * <li>there can be multiple clients (the max. is around 128 depending on your OS)</li>	 * <li>clients listen, request, and have testCases</li>	 * <li>clients can save data (write to XML)</li>	 * <li>clients have various other properties...</li>	 * </ul>	 * 	 * <ul>	 * <li>there must and can only be 1 server</li>	 * <li>the server has all client functionality</li>	 * <li>the server automatically relaunches if it were to crash (for an unknown reason)</li>	 * <li>the server automatically send out all received data to all connected clients</li>	 * <li>the server has various other properties...</li>	 * </ul>	 * 	 * <h2>Shutting down / closing sockets and clients:</h2>	 * <p>Sock includes it's own shutdown routine which is ran when closing your application	 * as long as you close your application normally (not force quit) all client sockets and	 * the server sockets should shut down correctly, when they don't there is about a 20 second	 * waiting time before your OS will unbind the sockets. For this reason it could occur that	 * when you relaunch your application the server is unable to start a socket server on the ports	 * you specified, do not worry, the script will automatically retry until it manages to setup	 * and/or connect the clients.</p>	 * 	 * @example Typical basic client setup: <listing version="3.0">	 * package {	 * 	 *	import flash.display.Sprite;	 * 	import flash.events.Event;	 * 	 *	import sock.Sock;	 *	import sock.events.CommEvent;	 * 	 * 	public class Example extends Sprite {	 * 	 * 	// add the Sock instance	 * 	public var client:Sock = Sock.getInstance();		 * 	 * 		public function Example() {	 * 				 * 			// set some settings properties (optional)	 * 			client.settings.fileName = 'mySettings';	 * 			client.settings.saveToDesktop = true;			 * 	 * 			// set some communicator properties (optional)	 * 			client.allowSave = false;	 * 			client.cueListEnabled = false;	 * 	 * 			// set some widget properties (optional)	 * 			client.widget.scrollbar = false;	 * 			client.widget.alwaysInFront = true;	 	 * 	 * 			// setup a global listener for all received test cases	 * 			client.addEventListener(CommEvent.ON_UPDATED_CASE, onCaseReceived);		 * 	 * 			// a setup listener for setupComplete	 * 			client.addEventListener(Sock.ON_SETUP_COMPLETE , onCommunicationSetup);	 * 	 * 			// initialize the client (the last step)	 * 			client.initialize('exampleClient', 'client', '10.0.0.1', 4444, 5555);	 * 		}	 * 	 * 		private function onCommunicationSetup(e:Event):void {	 * 					 * 			// client is running, do something...	 * 		}	 *				 * 		private function onCaseReceived(e:Event):void {	 * 					 * 			trace('received: '+e.case+' = '+e.value+' from '+e.application);	 * 		}	 * 	}	 * }	 * </listing>	 * 	 * @example Typical basic server setup: <listing version="3.0">	 * package {	 * 	 *	import flash.display.Sprite;	 * 	import flash.events.Event;	 * 	 *	import sock.Sock;	 *	import sock.events.CommEvent;	 * 	 *	public class Example extends Sprite {	 * 	 * 	// add the Sock instance	 * 	public var server:Sock = Sock.getInstance();		 * 	 * 		public function Example() {	 * 				 * 			// set some settings properties (optional)	 * 			server.settings.fileName = 'mySettings';	 * 			server.settings.saveToDesktop = true;			 * 	 * 			// set some communicator properties (optional)	 * 			server.allowSave = false;	 * 			server.cueListEnabled = false;	 * 	 * 			// set some widget properties (optional)	 * 			server.widget.scrollbar = false;	 * 			server.widget.alwaysInFront = true;	 * 	 * 			// a setup listener for setupComplete	 * 			server.addEventListener(Sock.ON_SETUP_COMPLETE , onCommunicationSetup);	 * 		 * 			// setup a global listener for all received test cases	 * 			server.addEventListener(CommEvent.ON_UPDATED_CASE, onCaseReceived);		 * 	 * 			// initialize the server	 * 			server.initialize('exampleServer', 'server', '10.0.0.1', 4444, 5555);	 * 		}	 * 			 * 		private function onCommunicationSetup(e:Event):void {	 * 					 * 			// the server is running, do something...	 * 		}	 *				 * 		private function onCaseReceived(e:Event):void {	 * 					 * 			trace('received: '+e.case+' = '+e.value+' from '+e.application);	 * 		}	 * 	}	 * }	 * </listing>	 * 	 */		public class Sock extends Sprite {				/* SINGLETONS ========== ========== ========== ========== ========== ========== ========== ========== ========== */		/** the instance of the settings class*/		public var settings:*;				/** the instance of the widget class */		public var widget:Widget=Widget.getInstance();				/** @private */		public var utils:Utils=Utils.getInstance();								// add utils				/* OPTIONAL SETTINGS === ========== ========== ========== ========== ========== ========== ========== ========== */				/** the widget logs the data this client/server itself send to the server which it then received back */		public var logOwnData				: Boolean		= false;		/** send and receive data as Objects, by default messages are send/received as UTFString, Object allows for things like BitmapData and Points		 * to be sent without complex conversions, but the packages are generally larger (= slower, which could cause errors) */		public var useObjects				: Boolean		= false;		/** allow server or client to save cases/values */		public var allowSave				: Boolean		= true;		/** enable cueList, if a client tries to send/request data while there isn't a connection with the server, these will be added		 * to the cueList and executed as soon as the connection is setup/restored */		public var cueListEnabled			: Boolean		= true;		/** makes the server save all incoming data (warning! the server will only save case and value, it WILL NOT save which		 * client the data came from */		public var serverAutoSavesIncoming	: Boolean		= false;		/** server auto echoes incoming data to all clients, this is the basic principle the whole system relies on... When this is set to false the client widget echo button will no longer work.*/		public var serverAutoEcho			: Boolean		= true;		/** time between reconnect attempts*/		public var reconnectionTime			: int			= 3000;		/** socket timeout time*/		public var timeOutTime				: int			= 5000;		/** socket object _compression algorithm ('zlib', 'deflate' or 'none'. Default is zlib*/		public var _compressionMethod		: String		= 'zlib';		/** disconnects Sock (client only) when the application is inactive/deactivated and reconnects once its active/reactivated, default = false*/		public var tombStoning				: Boolean		= false;		/** client scans for sock server (first tries the suggested IP in initialize(), if there's no server running at that IP.		 * the full subnet will be scanned for a server running at the specified ports (using the reconnectionTime interval)).		 * this property is experimental and might not work on mobile devices (since not all of them allow access to the IP address*/		public var autoDiscoverServer		: Boolean		= false;				/* OTHER PUBLIC VARS === ========== ========== ========== ========== ========== ========== ========== ========== */				/** @private */		public var localVars				: Object		= new Object();				// saved vars (for usage in app)		/** @private */		public var appName					: String;									// the name of the current app		/** @private */		public var setupComplete			: Boolean		= false;					// launch sequence complete		/** @private */		public var sendSocket				: Socket;									// the socket used to send (client)		/** @private */		public var receiveSocket			: Socket;									// the socket used to receive (client)				// only when supported		if (ServerSocket.isSupported == true) {					/** @private */		public var receiveServerSocket		: ServerSocket;							// receive server socket (server)		/** @private */		public var sendServerSocket			: ServerSocket;							// send server socket (server)		}				/** @private */		public var clientSendSockets		: Array		= new Array();				// all the send sockets (clients)		/** @private */		public var clientReceiveSockets		: Array		= new Array();				// all the receive sockets (clients)				/* PRIVATE VARS ======== ========== ========== ========== ========== ========== ========== ========== ========== */				private var _type					: String;									// the type, client or server		private var _ip						: String;									// ip address of the socket server		private var _sendPort				: int;										// port to send data		private var _receivePort			: int;										// port to send data				private var _testCases				: Array 		= new Array();				// the variables to check for		private var _requests				: Array			= new Array();				// open requests		private var _cueList				: Array			= new Array();				// waiting list for communicate (send data)		private var _clientSockets			: Array			= new Array();				// all the clients the server is connected to		private var _storedSocketData		: Array			= new Array();				// stored socket strings		private var _listeners				: Array			= new Array();				// array holding all listeners (+callback)				private var _mayClose				: Boolean		= false;					// allowed to close the socket (used for reconnect)		private var _closingServer			: Boolean		= false						// is the server shutting down?		private var _quitting				: Boolean		= false;					// used for exit routine				private var _connectionTimer		: Timer			= new Timer(reconnectionTime,0);		// reconnect timer		private var _upTimeTimer			: Timer			= new Timer(1000);						// runs every second				private var _startTime				: int;										// set as soon as connection is made		private var _prevString				: String = '';								// the previously received string for data comparison		private var _messageLength			: int = 0;									// length of the received message				private var _compression			: String;									// the _compression algorithm used for object mode				private var _suspended				: Boolean		= false;					// is the application currently suspended? (tombstoning, mobile)				/* EVENTS ==== ========= ========== ========== ========== ========== ========== ========== ========== ========== */				/** dispatched when the connection is first established (only once) */		public static const ON_SETUP_COMPLETE:String = "setupComplete";		private var _setupEvent:Event = new Event(ON_SETUP_COMPLETE, true, false);				/** dispatched by client or the server when a client establishes a connection */		public static const ON_CLIENT_CONNECT:String = "clientConnect";		private var _clientConnectEvent:Event = new Event(ON_CLIENT_CONNECT, true, false);				/** dispatched by client or the server when a client disconnects */		public static const ON_CLIENT_DISCONNECT:String = "clientDisconnect";		private var _clientDisconnectEvent:Event = new Event(ON_CLIENT_DISCONNECT, true, false);				/** dispatched by client or the server when a server establishes a connection */		public static const ON_SERVER_CONNECT:String = "serverConnect";		private var _serverConnectEvent:Event = new Event(ON_SERVER_CONNECT, true, false);				/** dispatched by client or the server when a server disconnects */		public static const ON_SERVER_DISCONNECT:String = "serverDisconnect";		private var _serverDisconnectEvent:Event = new Event(ON_SERVER_DISCONNECT, true, false);				/* INIT ====== ========= ========== ========== ========== ========== ========== ========== ========== ========== */   				/**		 * creates a server or client (with all the previously set properties), things to consider:		 * 		 * <ul>		 * 	<li>set all set all Sock/Widget properties BEFORE running initialize</li>		 * 	<li>communication between clients in done using the clients applicationName. In case of multiple clients, if clients are meant to communicate with eachother directly make sure each client has a unique applicationName</li>		 * 	<li>the serverIP and ports are important, the server will know a clientsIP/ports once the connection has been established (thats why you don't have to set them), 		 * make sure the computer running the server application has a static IP and check your router port forwarding settings</li>		 * 	<li>for each client/server 2 sockets are created, an incoming socket (for receiving data) and an outgoing socket (for sending data)</li>		 * </ul>		 * 		 * */		public function initialize(applicationName:String, type:String, serverIP:String, serverIncomingPort:int, serverOutgoingPort:int):void {						// set application name / type / ip			appName = applicationName;			_type = type;			_ip = serverIP;									widget.initialize(this, appName, _type, useObjects);			//addEventListener(LogEvent.ON_LOG, widget.onLogEvent);			addToLog("starting Sock v1.0", "standard");			// safe quit routine			NativeApplication.nativeApplication.addEventListener(Event.EXITING, onExiting);						//tombstoning			if (tombStoning == true) {				NativeApplication.nativeApplication.addEventListener(Event.ACTIVATE, onNativeAppActivated);				NativeApplication.nativeApplication.addEventListener(Event.DEACTIVATE, onNativeAppDeactivated);			}						_sendPort = serverOutgoingPort;			_receivePort = serverIncomingPort;						// use the basic XML settings class			settings = Settings.getInstance();			addChild(settings);						// update info (in overlay)			_upTimeTimer.addEventListener(TimerEvent.TIMER, getUptime);			updateInfo();						// add listener and load settings			if (allowSave == true) {									settings.addEventListener(settings.LOADED, launch);				settings.initialize(appName);			} else {								launch();			}			}				/** @private */		public function launch(e:Event = null):void {									// remove the initial listener			settings.removeEventListener(settings.LOADED, launch);						// write settings to localVars			localVars = settings.settingsObject						// set _compression method			set_compression();									// setup server			if (_type == "server") {								if (ServerSocket.isSupported == true) {					startServer();				} else {					throw new Error("ERROR: Device doesn't support SocketServer class");				}							} else {				startClient();				}		}				/* SERVER (done) ====== ========= ========== ========== ========== ========== ========== ========== ========== ========== */				/** start the Sock server (needs to be have been initialized using initialize()), 		 * call this function to restart the server after you've closed it using closeServer() */		public function startServer(e:Event = null):void {									addToLog("starting server", "standard", "server");						_closingServer = false;			// reset						// stop the connection timer if its running			if (_connectionTimer.running == true) {				_connectionTimer.stop();						}						try {								// setup send server socket				if (sendServerSocket == null || sendServerSocket.bound == false) {									sendServerSocket = new ServerSocket();			// clear socket server										// add listeners 					sendServerSocket.addEventListener(ServerSocketConnectEvent.CONNECT, connectHandler);					sendServerSocket.addEventListener(Event.CLOSE, onClose); 										// bind and listen					sendServerSocket.bind(_sendPort, _ip);					sendServerSocket.listen();										widget.menuBar.updateStatus("connecting");					addToLog( "outgoing socket binding to port:	"+sendServerSocket.localPort, "standard", "server" );				}								// setup receive server socket				if (receiveServerSocket == null || receiveServerSocket.bound == false) {										receiveServerSocket = new ServerSocket();		// clear socket server										// add listeners 					receiveServerSocket.addEventListener(ServerSocketConnectEvent.CONNECT, connectHandler);					receiveServerSocket.addEventListener(Event.CLOSE, onClose); 										// bind and listen					receiveServerSocket.bind(_receivePort, _ip);					receiveServerSocket.listen();										widget.menuBar.updateStatus("connecting");					addToLog( "incoming socket binding to port:	"+receiveServerSocket.localPort, "standard", "server" );				}								if (sendServerSocket.bound == true && receiveServerSocket.bound == true) {										_upTimeTimer.start();		// start the uptime timer					setStartTime();				// set the application start time										// stop the reconnect timer					if (_connectionTimer.running == true) {						_connectionTimer.stop();						_connectionTimer.removeEventListener(TimerEvent.TIMER, startServer);					}										widget.menuBar.updateStatus("connected");					addToLog( "sock server running at ip:		"+_ip, "important", "server" );					addToLog("===== ===== ===== ===== ===== ===== ", "grey");					widget._activityOverlay.ipAddress.text = _ip;										dispatchEvent(_serverConnectEvent);										// setup (server) complete					if (setupComplete == false) {						setupComplete = true;						dispatchEvent(_setupEvent);					}									}							} catch (error:Error) {												if (_connectionTimer.running == false) {										// reset the connection timer					_connectionTimer.addEventListener(TimerEvent.TIMER, startServer);					_connectionTimer.start();										addToLog( "can't establish sock server socket(s), retrying", "warning", "server" );					widget.menuBar.updateStatus("connecting");				}			}					}				/** closes the Sock server */		public function closeServer():void {									_closingServer = true;			// the server is closing						if (_clientSockets.length == 0) {								// no clients, close server				disconnectServer();								} else {									addToLog("preparing to shut down server", "grey", "server");								// there are still sockets connected, send a message so the clients will close				serverEcho("server", "SOCKSERVER", "closing");							}		}				// close the socket server (done)		private function disconnectServer():void {						// close the receive socket server			if (receiveServerSocket != null && receiveServerSocket.bound == true) {								clientReceiveSockets = new Array();		// reset array								// close the receive server socket				receiveServerSocket.close();								widget.menuBar.updateClients();				addToLog( "unbinding incoming socket port:	"+_sendPort, "standard", "server" );;				widget.menuBar.updateStatus("connecting");			}						// close the send socket server			if (sendServerSocket != null && sendServerSocket.bound == true) {								clientSendSockets = new Array();		// reset array								// close the send server socket				sendServerSocket.close();								widget.menuBar.updateClients();				addToLog( "unbinding outgoing socket port:	"+_receivePort, "standard", "server" );;				widget.menuBar.updateStatus("connecting");			}						// if both server sockets are disconnected (and no longer exist), reset lots of stuff			if (sendServerSocket != null && sendServerSocket.bound == false || receiveServerSocket != null && receiveServerSocket.bound == false) {								// if the application is shutting down, really shut it down!				if (_quitting == true) {					NativeApplication.nativeApplication.exit();					return;				}								_clientSockets = new Array();		// reset array								widget.menuBar.updateClients();		// update connected clients				_upTimeTimer.stop();				// stop uptime timer				_connectionTimer.stop();			// stop attempting to setup the server								widget._infoOverlay.uptime.value.text = "-";	// clear uptime values				widget._infoOverlay.uptime.value.text = "-";	// clear uptime values								// if the application is shutting down, really shut it down!				if (_quitting == true) {					NativeApplication.nativeApplication.exit();				}								dispatchEvent(_serverDisconnectEvent);								addToLog( "sock server closed", "important", "server" );;				addToLog("===== ===== ===== ===== ===== ===== ", "grey");				widget.menuBar.updateStatus("disconnected");							}					}				// if a client connects to a server socket (done)		private function connectHandler(event:ServerSocketConnectEvent = null):void { 						var socket:Socket = event.socket as Socket;									// the client connecting			socket.addEventListener(IOErrorEvent.IO_ERROR, onIOError); 					// add error listener			socket.flush();						// if client is connecting to server receive socket (server receives from client send)			if (socket.localPort == _receivePort) {								socket.addEventListener(Event.CLOSE, onClientSendClose);				// add close listener				socket.addEventListener( ProgressEvent.SOCKET_DATA, storeSocketData); 	// listen for data comming through this socket				clientSendSockets.push(socket);											// add to client send socket array													addToLog( "established incoming connection:	"+socket.localPort+' - '+socket.remotePort, 'important', 'server');							} 						// if client is connection to server send socket (server sends to client receive)			else if (socket.localPort == _sendPort) {								socket.addEventListener(Event.CLOSE, onClientReceiveClose);				// add close listener				clientReceiveSockets.push(socket);										// add to client receive socket array								addToLog( "established outgoing connection:	"+socket.localPort+' - '+socket.remotePort, 'important', 'server');								// try sending strings on cueList (if server has waiting list and no clients were connected)								setTimeout(parseCueList, 100);				//parseCueList();			}						_clientSockets.push(socket);												// add client socket to array						widget.menuBar.updateClients();												// update the clients			dispatchEvent(_clientConnectEvent);					}				// send a message to all connected clients (done)		private function serverEcho(_application:String, _case:String, _value:*):void {						for each (var _socket:Socket in clientReceiveSockets) {								if (_socket != null && _socket.connected == true) {										// send it out					writeToSocket(_application, _case, _value, _socket);									}			}		}				// if a client send socket closes (done)		private function onClientSendClose( event:Event ):void { 						var socket:Socket = event.target as Socket 			socket.flush();						_clientSockets.splice(_clientSockets.indexOf(socket), 1);				// remove the client from array			clientSendSockets.splice(clientSendSockets.indexOf(socket), 1);			// remove the client from send socket array						dispatchEvent(_clientDisconnectEvent);						widget.menuBar.updateClients();											// update clients			addToLog( "client closed incoming connection", "standard", "server");						allClientsClosed();		} 				// if a client receive socket closes (done)		private function onClientReceiveClose(event:Event):void { 						var socket:Socket = event.target as Socket 			socket.flush();						_clientSockets.splice(_clientSockets.indexOf(socket), 1);				// remove the client from array			clientReceiveSockets.splice(clientReceiveSockets.indexOf(socket), 1);	// remove the client from receive socket array						dispatchEvent(_clientDisconnectEvent);						widget.menuBar.updateClients();											// update clients			addToLog( "client closed outgoing connection", "standard", "server");						allClientsClosed();					} 				// runs after a client has closed		private function allClientsClosed():void {						// if the server is closing and there are no more clients connected			if (_clientSockets.length == 0 && _closingServer == true) {								addToLog( "all client connections closed, shutting down","standard", "server");				closeServer();			}		}				// on error		private function onIOError( errorEvent:IOErrorEvent ):void 		{ 			trace( "IOError: " + errorEvent.text ); 		} 				// if the server closes for no reason (done)		private function onClose( event:Event ):void 		{ 			// if the server wasn't meant to close			if (_closingServer = false) {								// stop the connection timer isn't running, start it (reconnect)				if (_connectionTimer.running == false) {					_connectionTimer.start();							}			}		} 				/* CLIENT ====== ========= ========== ========== ========== ========== ========== ========== ========== ========== */				/** start the Sock client (needs to be have been initialized using initialize()), 		 * call this function to restart the client after you've closed it using closeClient() */		public function startClient():void {									if (_connectionTimer.running == true) {				_connectionTimer.stop();				if (autoDiscoverServer) {					_connectionTimer.removeEventListener(TimerEvent.TIMER, scanForServer);					} else {					_connectionTimer.removeEventListener(TimerEvent.TIMER, connectClientToServer);					}			}												addToLog("starting client", "standard", 'socket');						// setup socket connection and start listening			if (receiveSocket == null || receiveSocket.connected == false || sendSocket == null || sendSocket.connected == false) {								// clear sendSocket				sendSocket = null;				sendSocket = new Socket();								//add listener for send socket						sendSocket.timeout = timeOutTime;				sendSocket.addEventListener(Event.CLOSE, closeHandlerSend);				sendSocket.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandlerSend);				sendSocket.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);				sendSocket.addEventListener(Event.CONNECT, launchComplete);								// clear receiveSocket				receiveSocket = null;				receiveSocket = new Socket();								//add listener for receive socket				receiveSocket.timeout = timeOutTime;				receiveSocket.addEventListener(Event.CLOSE, closeHandlerReceive);				receiveSocket.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandlerReceive);				receiveSocket.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);				receiveSocket.addEventListener(Event.CONNECT, launchComplete);								// connect to socket server				if (autoDiscoverServer) {					_connectionTimer.addEventListener(TimerEvent.TIMER, scanForServer);					} else {					_connectionTimer.addEventListener(TimerEvent.TIMER, connectClientToServer);					}				connectClientToServer();			}		}				/** closes the Sock client */		public function closeClient():void{			//_mayClose = true;						if (_connectionTimer != null && _connectionTimer.running == true) {				_connectionTimer.stop();			}						if (sendSocket != null && sendSocket.connected == true) {				addToLog("closing outgoing connection:		"+sendSocket.localPort+" - "+sendSocket.remotePort, "standard", 'socket');				sendSocket.close();				sendSocket = null;			}			if (receiveSocket != null && receiveSocket.connected == true) {				addToLog("closing incoming connection:		"+receiveSocket.localPort+" - "+receiveSocket.remotePort, "standard", 'socket');				receiveSocket.close();				receiveSocket = null;			}						if (sendSocket == null && receiveSocket == null || sendSocket.connected == false && receiveSocket.connected == false) {				addToLog("sock client closed", "important", 'socket');				addToLog("===== ===== ===== ===== ===== ===== ", "grey");				widget.menuBar.updateConnection("disconnected");				_upTimeTimer.stop();				widget._infoOverlay.uptime.value.text = "-";			}		}				/** scan the local subnet for servers (based on _ip as name) */		private function scanForServer(e:TimerEvent):void {						addToLog("scanning for server", "standard", 'socket');						// clear the IP address			_ip = "";						// stop the connection timer if its running			if (_connectionTimer.running == true) {				_connectionTimer.stop();						}						var ipArray:Array = getIp().split(".");			ipArray.pop();	//pop the last bit						var subnet:String = ipArray.join(".");						// loop through the ip range			for (var i:uint = 0; i < 255; i++) {								//attempt to connect				var nameRequestSocket:Socket = new Socket();				nameRequestSocket.timeout = 1000;				nameRequestSocket.addEventListener(IOErrorEvent.IO_ERROR, socketScanIOError);				nameRequestSocket.addEventListener(SecurityErrorEvent.SECURITY_ERROR, socketScanIOError);				nameRequestSocket.addEventListener(ServerSocketConnectEvent.CONNECT, socketScanConnect);								try {															nameRequestSocket.connect(subnet+"."+i, _sendPort);				} catch(e:Error) {										addToLog("scanning error!", "warning", 'socket');										errorCount ++;				}			}		}				private var errorCount:uint;				// on scan IOError, do nothing except for the last IP in the range		private function socketScanIOError(event:IOErrorEvent):void {					errorCount ++ ;						if (errorCount == 255) {								errorCount = 0;								// resume the connection timer if its stopped				if (_connectionTimer.running == false && _ip == "") {					_connectionTimer.start();							}			}		}				// when the scan connected to something		private function socketScanConnect(event:Event):void {						errorCount = 0;						var socket:Socket = event.target as Socket;			_ip = socket.remoteAddress;			socket.flush();			socket.close();			socket = null;			connectClientToServer();		}				private function connectClientToServer(e:Event = null):void {						if (sendSocket != null || sendSocket.connected == false) {								sendSocket.connect(_ip, _receivePort);				addToLog("estabishing incoming connection:	"+_receivePort, "standard", 'socket');				widget.menuBar.updateConnection("connecting");			}						if (receiveSocket != null || receiveSocket.connected == false) {								receiveSocket.connect(_ip, _sendPort);				addToLog("estabishing outgoing connection:	"+_sendPort, "standard", 'socket');				widget.menuBar.updateConnection("connecting");			}		}				private function closeHandlerSend(event:Event):void {						var socket:Socket = event.target as Socket;			socket.flush();						if (_mayClose == false) {								addToLog("socket disconnected: outgoing socket, reconnecting", "warning", 'socket');								_upTimeTimer.stop();				widget._infoOverlay.uptime.value.text = "-";				widget.menuBar.updateConnection("disconnected");								if (_connectionTimer.running == false) {					_connectionTimer.start();					widget.menuBar.updateConnection("connecting");				} else {					widget.menuBar.updateConnection("connecting");				}							} else {								addToLog("outgoing socket closed", "important", 'socket');				widget.menuBar.updateConnection("disconnected");							}		}				private function closeHandlerReceive(event:Event):void {						var socket:Socket = event.target as Socket;			socket.flush();						if (_mayClose == false) {								addToLog("socket disconnected: incoming socket, reconnecting", "warning", 'socket');								_upTimeTimer.stop();				widget._infoOverlay.uptime.value.text = "-";				widget.menuBar.updateConnection("disconnected");								if (_connectionTimer.running == false) {					_connectionTimer.start();					widget.menuBar.updateConnection("connecting");				} else {					widget.menuBar.updateConnection("connecting");				}							} else {								addToLog("incoming socket closed", "important", 'socket');				widget.menuBar.updateConnection("disconnected");			}		}				private function ioErrorHandlerSend(event:IOErrorEvent):void {									addToLog("unable to establish outgoing connection", "warning", 'socket');						_upTimeTimer.stop();			widget._infoOverlay.uptime.value.text = "-";						//widget.menuBar.updateConnection("disconnected");			if (_connectionTimer.running == false) {				_connectionTimer.start();				widget.menuBar.updateConnection("connecting");			} else {				widget.menuBar.updateConnection("connecting");			}		}				private function ioErrorHandlerReceive(event:IOErrorEvent):void {									addToLog("unable to establish incoming connection", "warning", 'socket');						_upTimeTimer.stop();			widget._infoOverlay.uptime.value.text = "-";						//widget.menuBar.updateConnection("disconnected");			if (_connectionTimer.running == false) {				_connectionTimer.start();				widget.menuBar.updateConnection("connecting");			} else {				widget.menuBar.updateConnection("connecting");			}		}				private function securityErrorHandler(event:SecurityErrorEvent):void {			addToLog("securityErrorHandler: " + event, "warning", 'socket');			//widget.menuBar.updateConnection("disconnected");		}				// socket is connected (done)		private function launchComplete(e:Event = null):void {						// connection setup succesfully			if (sendSocket.connected == true && receiveSocket.connected == true) {								addToLog("established outgoing connection:	"+sendSocket.localPort+" - "+sendSocket.remotePort, "important", 'socket');												addToLog("established incoming connection:	"+receiveSocket.localPort+" - "+receiveSocket.remotePort, "important", 'socket');												if (sendSocket.localAddress == null) {					addToLog('sock client running at unknown ip', "important", 'socket');					widget._activityOverlay.ipAddress.text = 'IP Unknown';				} else {					addToLog('sock client running at ip:	'+sendSocket.localAddress, "important", 'socket');					widget._activityOverlay.ipAddress.text = String(sendSocket.localAddress);				}								addToLog("===== ===== ===== ===== ===== ===== ", "grey");				widget.menuBar.updateConnection("connected");								// add the data listener				receiveSocket.addEventListener(ProgressEvent.SOCKET_DATA, storeSocketData);								if (setupComplete == false) {					setupComplete = true;					dispatchEvent(_setupEvent);				}								// connect to socket server				if (_connectionTimer.running == true) {					_connectionTimer.stop();				}								// get the time and start uptime timer				_upTimeTimer.start();				setStartTime();								// try sending strings on cueList (if server has waiting list and no clients were connected)				parseCueList();			}		}				/* COMMUNICATION ====== ========= ========== ========== ========== ========== ========== ========== ========== ========== */				/** send a case/value through socket */		public function send(_case:String, _value:*, _save:Boolean = false, _instaSave:Boolean = false):void {									communicate(_case,_value,_save,_instaSave,true)		}				/** send out a request (active): request a case/value from another open application through Sock, only executed once,		 * only works for direct apps (names), 'all' and '*' are not supported 		 * 		 * @example request(): <listing version="3.0">		 * package {		 * 		 *	import flash.display.Sprite;		 * 	import flash.events.Event;		 * 		 *	import sock.Sock;		 *	import sock.events.CommEvent;		 * 		 *	public class Example extends Sprite {		 * 		 * 	// add the Sock instance		 * 	public var client:Sock = Sock.getInstance();			 * 		 * 		public function Example() {		 * 					 * 			// a setup listener for setupComplete		 * 			client.addEventListener(Sock.ON_SETUP_COMPLETE , onCommunicationSetup);		 * 		 * 			// initialize the client		 * 			client.initialize('exampleClient', 'client', '10.0.0.1', 4444, 5555);		 * 		}		 * 		 * 		private function onCommunicationSetup(e:Event):void {		 * 						 * 			// request case/value from 'anotherClient' (this can also be the server if serverAutoSavesIncoming = true)		 * 			// only sent out once, if 'anotherClient' is running it will always respond, even if it doesn't have a case called 'uptime' 		 * 			client.request('anotherClient', 'uptime', 'int', updateTime);		 * 		}		 *					 * 		private function updateTime(e:Event):void {		 * 						 * 			// example		 * 			myTextField.text = 'serverUptime = '+e.value; 		 * 		 * 		}		 * 	}		 * }		 * </listing>		 * */		public function request(_targetApp:String, _case:String, _returnType:String, _callBack:Function):void {						var callBack:Function;			callBack = _callBack;						// add to array			_requests.push([_targetApp, _case, _returnType, callBack]);						if (_type == 'server') {								if (setupComplete == false && cueListEnabled == true || _clientSockets.length == 0 && cueListEnabled == true) {					cueList(_case, 'requestValue', false, false, true, _targetApp);					return;									} else {										serverEcho(_targetApp, _case, 'requestValue');					addToLog('requested through socket from '+_targetApp+': '+_case, "standard", "outgoing");					return;				}							} else {								if (setupComplete == false && cueListEnabled == true || sendSocket == null || sendSocket.connected == false && cueListEnabled == true) {					cueList(_case, 'requestValue', false, false, true, _targetApp);					return;								} else {										// send it out					writeToSocket(_targetApp, _case, 'requestValue', sendSocket);					addToLog('requested through socket: '+_targetApp+' = '+_case, "standard", "outgoing");					return;				}			}		}				/* USER LISTENERS ========= ========== ========== ========== ========== ========== ========== ========== ========== */				/** add a testcase (application/case/value) to listen for (passive), ('all' or '*' = all open clients/server), 		 * triggers a commEvent when case is matched through socket connection 		 * 		 * @example addTestCase() / removeTestCase(): <listing version="3.0">		 * package {		 * 		 *	import flash.display.Sprite;		 * 	import flash.events.Event;		 * 		 *	import sock.Sock;		 *	import sock.events.CommEvent;		 * 		 *	public class Example extends Sprite {		 * 		 * 	// add the Sock instance		 * 	public var server:Sock = Sock.getInstance();			 * 		 * 		public function Example() {		 * 					 * 			// a setup listener for setupComplete		 * 			server.addEventListener(Sock.ON_SETUP_COMPLETE , onCommunicationSetup);		 * 			 * 			// setup a global listener for all received test cases		 * 			server.addEventListener(CommEvent.ON_UPDATED_CASE, onCaseReceived);			 * 		 * 			// initialize the server		 * 			server.initialize('exampleServer', 'server', '10.0.0.1', 4444, 5555);		 * 		}		 * 				 * 		private function onCommunicationSetup(e:Event):void {		 * 						 * 			// the Sock server is running, add testcase		 * 			// test for case name 'userName' from application 'testClient' which I'd like to receive as a string		 * 			// when a case matching these criteria (the application name, and case name), a commEvent is dispatched		 * 			// which is caught by onCaseReceived()		 * 			server.addTestCase('testClient', 'userName', 'string');		 * 		}		 *					 * 		private function onCaseReceived(e:Event):void {		 * 						 *			// trace incoming data		 * 			trace('received: '+e.case+' = '+e.value+' from '+e.application);		 * 		 * 			// if it matches testClient/userName		 * 			if (e.application == 'testClient' || e.case == 'userName') {		 * 							 * 			// remove the test case, we only wanted userName once		 * 			server.removeTestCase('testClient', 'userName', 'string');		 * 							 * 			// set the text of a textField (example)		 * 			myTextField.text = e.value;		 * 		}		 * 	}		 * }		 * </listing>		 * */		public function addTestCase(_application:String = 'all', _case:String = 'all', _returnType:String = 'string'):void {						_testCases.push([_application, _case, _returnType]);			addToLog('test case added: '+_application+' '+_case+' ('+_returnType+')', 'standard', 'socket');		}				/** remove a testcase set using addTestCase() */		public function removeTestCase(_application:String, _case:String, _deleteSaved:Boolean):void {						for (var i:int; i < _testCases.length; i++) {				if (_testCases[i][0] == _application && _testCases[i][1] == _case) {										// delete from testCases array					_testCases.splice(i, 1)										// delete from localVars					if (_deleteSaved == true) {						localVars.splice(localVars.indexOf(_case), 1);						settings.deleteSetting(_case, true);					}										return;				}			}		}				/** listen for a application/case/value (passive), ('all' or '*' = all open clients/server) has a callback function 		 * 		 *  * @example listenFor() / stopListeningFor(): <listing version="3.0">		 * package {		 * 		 *	import flash.display.Sprite;		 * 	import flash.events.Event;		 * 		 *	import sock.Sock;		 *	import sock.events.CommEvent;		 * 		 *	public class Example extends Sprite {		 * 		 * 	// add the Sock instance		 * 	public var server:Sock = Sock.getInstance();			 * 		 * 		public function Example() {		 * 					 * 			// a setup listener for setupComplete		 * 			server.addEventListener(Sock.ON_SETUP_COMPLETE , onCommunicationSetup);		 * 		 * 			// initialize the server		 * 			server.initialize('exampleServer', 'server', '10.0.0.1', 4444, 5555);		 * 		}		 * 		 * 		private function onCommunicationSetup(e:Event):void {		 * 						 * 			// listen for case 'position' from 'anotherClient', received data casted as an array		 * 			// when data is received matching these criteria, execute callback function		 * 			// you could also set useObjects = true (in both server and client) to send a location as a Point()		 * 			server.listenFor('anotherClient', 'position', 'array', moveItem);		 * 		}		 *					 * 		private function moveItem(e:Event):void {		 * 						 * 			// remove the listener since we only wanted to run this once		 * 			server.stopListeningFor('all', 'position', 'point');		 * 										 * 			//move an item to the e.value.x e.value.y		 * 			item.x = e.value[0];		 * 			item.y = e.value[1];		 * 		}		 * 	}		 * }		 * </listing>		 * */		public function listenFor(_targetApp:String = "all", _case:String = "all", _returnType:String = "all", _callBack:Function = null):void {						var callBack:Function;			callBack = _callBack;			_listeners.push([_targetApp, _case, _returnType, callBack]);						addToLog('listener added for: '+_targetApp+' '+_case+' ('+_returnType+')', 'standard', 'socket');		}				/** removes a listener set using ListenFor(), ('all' or '*' = all open clients/server) */		public function stopListeningFor(_targetApp:String = "all", _case:String = "all", _returnType:String = "all"):void {						for (var i:int = 0; i < _listeners.length; i++) {								// if its a match				if(_listeners[i][0] == _targetApp && _listeners[i][1] == _case && _listeners[i][2] == _returnType) {										// remove from array					_listeners.splice(i, 1);									}							}					}				/* USER DATA HANDLING ====== ========== ========== ========== ========== ========== ========== ========== ========== */				/** remove a case and its value from memory and saved settings file (XML)		 * instaDel instantly saves the changes to XML (default is false) */		public function deleteSetting(caseName:String, instaDel:Boolean = false):void {						addToLog('deleting setting: '+caseName, "standard", "save");						localVars[caseName] = null;			delete(localVars[caseName]);						settings.deleteSetting(caseName, instaDel);					}				/** remove all case and their values from memory and saved settings file (XML) 		 * instaDel instantly saves the changes to XML (default is true) */		public function deleteAllSettings(instaDel:Boolean = true):void {						addToLog('deleting all settings', "standard", "save");						localVars = new Object();						settings.deleteAllSettings(instaDel);					}				/** clear the value of a case from memory and saved settings file (XML) 		* instaSave instantly saves the changes to XML (default is false) */		public function clearSetting(caseName:String, instaClear:Boolean = false):void {						addToLog('clearing value of: '+caseName, "standard", "save");						localVars[caseName] = null;						// save setting to XML			if (instaClear == true) {				settings.addSetting(caseName, localVars[caseName], true);			}		}				/** clear all the values of all cases from memory and saved settings file (XML) 		 * instaSave instantly saves the changes to XML (default is true) */		public function clearAllSettings(instaClear:Boolean = true):void {						addToLog('clearing all values of all settings', "standard", "save");						var count:int = 0;						// get the keys			var keys:Array = new Array();			for (var _key:String in localVars) {				keys.push(_key);			}						for each(var obj:Object in localVars) {				localVars[keys[count]] = null;				count++;			}									// clear all settings			settings.clearAllSettings(instaClear);					}				/** fetch a case value, specify a type to return it as (int, string, number, array, object) */		public function fetchSetting(caseName:String, type:String):* {						var _value:*;									if (localVars[caseName] && getQualifiedClassName(localVars[caseName]) != 'Object') {								_value = utils.stringToObject(type, localVars[caseName]);				addToLog('returned value for: '+caseName, "standard", "load");							} else if (getQualifiedClassName(localVars[caseName]) == 'Object') {							_value = localVars[caseName];				addToLog('returned object for: '+caseName, "standard", "load");			} else {												_value = utils.stringToObject(type);				addToLog('requested data not found, returned null for '+caseName, "warning", "load");			}						return _value;		}				/** save a case/value to settings file (XML) without sending it through the socket communicator		* instaSave instantly saves the changes to XML (default is false) */		public function saveSetting(caseName:String, value:*, instaSave:Boolean = false):void {						// never save the internal commands			if (caseName == "SOCKSERVER" || caseName == "SOCKCLIENT") {				return;			}						localVars[caseName] = value;						addToLog('saving: '+caseName+' = '+value, 'standard', 'save');						// save setting to XML			if (instaSave == true) {				settings.addSetting(caseName, value, true);			} else {				settings.addSetting(caseName, value);			}		}				/** update all settings, use this in combination with send(), deleteSetting(), deleteAllSettings(), clearSetting(),		 * clearAllSettings() and saveSetting() set instaSave/instaDelete to false and save once using this function		 *  		 * @example instaSave/instaDel/instaClear = false for using updateSettings(): <listing version="3.0">		 * 		 * // send some data that should also be saved		 * // (sending will happen instantly, saving won't (instaSave = false))		 * client.send('var1', 'value1', true);		 * client.send('var2', 'value2', true);		 * 		 * // set some other data to be saved		 * // (instaSave = false)		 * client.saveSetting('var3', 'value3');		 * client.saveSetting('var4', 'value4');		 * 		 * // set some data to be cleared from settings		 * // (instaClear = false)		 * client.clearSetting('var5');		 * client.clearSetting('var6');		 * 		 * // delete some settings completely		 * // (instaDel = false)		 * client.deleteSetting('var7');		 * client.deleteSetting('var8');		 * 		 * // trigger the settings file updating (deleting/clearing/saving of settings) only once! 		 * // (all instaSave/instaDel/instaClear settings were set to false)		 * client.updateSettings();		 * 		 * </listing> 		* */		public function updateSettings():void {			settings.updateSettings();		}				/** clear the cueList (the cueList holds all cases to request/send once connection is established), 		 * if you dont want a cueList at all set cueListEnabled = false */		public function clearCueList():void {			_cueList = new Array();		}				/* INTERNAL MECHANISMS ====== ========== ========== ========== ========== ========== ========== ========== ========== */				// sends data to socket (done)		private function communicate(_case:String, _value:*, _save:Boolean = false, _instaSave:Boolean = false, _sendToSocket:Boolean = true, _targetApp:String = null):void {						// added to allow requests, if targetApp is filled, its a request, otherwise we're just sending data out			if (_targetApp == null) {				_targetApp = appName;			}			// if server			if (_type == "server") {								// check to see if setup has completed, if not, add everything to waiting list				if (setupComplete == false && cueListEnabled == true || clientReceiveSockets.length == 0 && cueListEnabled == true) {														cueList(_case, _value, _save, _instaSave, true, _targetApp);					return;									} else if (setupComplete == true && clientReceiveSockets.length > 0) {										serverEcho(_targetApp, _case, _value);					localVars[_case] = _value;										if (_sendToSocket == true) {						addToLog('sending: '+_case+' = '+String(_value), "standard", "outgoing");					} else {						addToLog('only saving: '+_case+' = '+String(_value), "standard", "save");					}										// save setting to XML					if (_save == true && allowSave == true) {						settings.addSetting(_case, _value, _instaSave);					} else if (_save == true && allowSave == false)  {						addToLog("won't save: "+_case+' = '+String(_value), "grey", "save");					}				}								return;			}						// if client			if (_type == "client") {								// check to see if setup has completed, if not, add everything to waiting list				if (setupComplete == false || sendSocket == null || sendSocket.connected == false || receiveSocket == null || receiveSocket.connected == false) {														if ( cueListEnabled == true) {						cueList(_case, _value, _save, _instaSave, true, _targetApp);					}										return;									} else {														// send it out					writeToSocket(_targetApp, _case, _value, sendSocket);										localVars[_case] = _value;										if (_sendToSocket == true) {						addToLog('sending: '+_case+' = '+String(_value), "standard", "outgoing");					} else {						addToLog('only saving: '+_case+' = '+String(_value), "standard", "save");					}										// save setting to XML					if (_save == true && allowSave == true) {												settings.addSetting(_case, _value, _instaSave);					} else if (_save == true && allowSave == false)  {						addToLog("won't save: "+_case+' = '+String(_value), "grey", "save");					}				}								return;			}		}				// check if there are things to be send / requested		private function parseCueList():void {						// check if theres something waiting to be sent or requested						if (_cueList.length > 0) {								for (var i:int; i < _cueList.length; i++) {										communicate(_cueList[i][0],_cueList[i][1],_cueList[i][2],_cueList[i][3],_cueList[i][4],_cueList[i][5]);				}								_cueList = new Array();			}		}				// write a string to the socket (done)		private function writeToSocket(_application:String, _case:String, _value:*, _socket:Socket):void {						if (_socket != null && _socket.connected == true) {								var bytes:ByteArray;								_socket.objectEncoding = 0;								if (useObjects == true) {																var _container:Object = new Object();					var _subcontainer:Object = new Object();															_subcontainer['application'] = String(_application);					_subcontainer['case'] = String(_case);					_subcontainer['value'] = _value;					_subcontainer['sendTime'] = utils.getTime();					_container['data'] = _subcontainer;										bytes = new ByteArray();					bytes.writeObject(_container);					bytes.position = 0;															if (_compression != null) {												bytes.compress(_compression);					}										_socket.writeUnsignedInt(bytes.length); 		// write object length					_socket.writeInt(1);										_socket.objectEncoding = 3;										_socket.writeBytes(bytes);						// write the object									} else {															//combine in single string					var _socketString: String = String(utils.getTime())+'_'+String(_application)+'_'+String(_case)+'_'+JSON.stringify(_value)+'/';										// just to get the length in bytes...					bytes = new ByteArray();					bytes.writeUTF(_socketString);					_socket.writeUnsignedInt(bytes.length);					_socket.writeInt(0);					_socket.writeUTF(_socketString);				}								_socket.flush();				return;							} else if (_type == "client" && _socket == null || _type == "client" && _socket.connected == false) {								connectClientToServer();				return;							}					}				// waiting list for communicate() when the communicator isn't fully setup yet (done)		private function cueList(_case:String, _value:*, _save:Boolean = false, _instaSave:Boolean = false, _sendToSocket:Boolean = true, _application:String = 'all'):void {						//loop through to see if case is already on list			for (var i:int; i < _cueList.length; i++) {				if (_cueList[i][0] == _case) {					_cueList[i] = [_case, _value, _save, _instaSave, _sendToSocket, _application];					addToLog('cueList item updated ('+_case+' = '+String(_value)+')', "standard", "standard");					return;				}			}						_cueList.push([_case, _value, _save, _instaSave, _sendToSocket, _application]);			addToLog('item added to cueList ('+_case+')', "standard", "standard");		}				/* SOCKET DATA PARSING ====== ========== ========== ========== ========== ========== ========== ========== ========== */				// store the socket data		private function storeSocketData(event:ProgressEvent = null):void {									var socket:Socket = event.target as Socket;							socket.objectEncoding = 0;			//Read the data from the socket			try			{				while( socket.bytesAvailable >= 4 )//while there is at least enough data to read the message size header				{					if(_messageLength == 0) //is this the start of a new message block?					{						_messageLength = socket.readUnsignedInt(); //read the message length header					}										if(_messageLength <= socket.bytesAvailable) //is there a full message in the socket?					{						var _data:*;						var _type:int = socket.readInt(); //read the message type header												//Read the message based on the type						if( _type == 1 ) {														socket.objectEncoding = 3;														var _bytes:ByteArray = new ByteArray();							socket.readBytes(_bytes, 0, _messageLength);							_messageLength = 0; //finished reading this message														if (_compression != null) {								_bytes.uncompress(_compression);							}														//parse as object							_data = new Object();							_data = _bytes.readObject();														// object parser							if (_data.length > 2) {								addToLog('received combined data, overloading socket!', "warning", "socket");							}														// there will always be a single object per call...							for each (var object:Object in _data) {																								//data comparison								if (String(object.sendTime+object.application+object['case']) == _prevString) {									addToLog('received duplicate data, ignoring', "warning", "socket");								} else {									_prevString = String(object.sendTime+object.application+object['case']);									parseSocketData(object['sendTime'], object['application'], object['case'], object['value']);								}							}																			} else if ( _type == 0 ) {							// parse as string							_data = new Array();							_data = String(socket.readUTF()).split('/');														//string parser							if (_data.length > 2) {								addToLog('received combined data, overloading socket!', "warning", "socket");							}																					for each (var string:String in _data) {																if (string != '') {									splitSocketData(string);								}							}						}					}					else { //The current message isn't complete -- wait for the socketData event and try again						break;					}				}			}			catch (e:Error) {								if (Socket(event.target).connected) {					addToLog('error parsing received socket data', "warning", "socket");				}			}					}				// split the socket data in 3 parts (_app, _case, _value) (done)		private function splitSocketData(_dataString:String):void {						//data comparison based on sendTime			if (_prevString == _dataString) {				addToLog('received duplicate data, ignoring', "warning", "socket");				return;			} else {				_prevString = _dataString;			}						// splits data array bij : (geeft 3 delen appName, varname, waarde)			var _divider		:String		= '_';			var _dataArray		:Array		= _dataString.split(_divider);						// the application			var _sendTime		:	int			= int(_dataArray[0]);			var _application	:	String		= String(_dataArray[1]);			var _case			:	String		= String(_dataArray[2]);						_dataArray.splice(0, 3);						var	_value		:	String		= String(_dataArray);						parseSocketData(_sendTime, _application, _case, _value);		}				// parse the socket data (done)		private function parseSocketData(_sendTime:int, _application:String, _case:String, _value:*):void {						if (_type == "server" && _application != appName) {								if (serverAutoEcho == true) {					// echo everything					addToLog('echoing received data', "grey", "server");					widget.menuBar.setActivity('outgoing');					serverEcho(_application, _case, _value);				}								if (serverAutoSavesIncoming == true && allowSave == true) {										if (_case != "SOCKCLIENT") {						// save everything						addToLog('saving received data', "grey", "server");						saveSetting(_case, _value, true);					}				}			} 						if (_type == "client" && _case == "SOCKSERVER" && _value == "closing") {				sendSocket.close();				receiveSocket.close();				_connectionTimer.start();				addToLog('server requested shutdown, reconnecting in ('+reconnectionTime / 1000+' sec.)', "standard", 'socket');				widget.menuBar.updateConnection("connecting");				_upTimeTimer.stop();				widget._infoOverlay.uptime.value.text = "-";				return;			}									if (_application == appName) {								if (_case == "SOCKCLIENT" && _value == "echo") {										// if echo (communication test)					addToLog('received echo from sock server', "important", "incoming");					return;								} else if (_value == 'requestValue') {									addToLog('received request for '+_case+', sending: '+String(localVars[_case]), "standard", "incoming");										// if another app is requesting from this app, send the requested data back					communicate(_case, localVars[_case], false, false);					return;								} else if (logOwnData == true) {					// log unused					addToLog('received own data: '+_application+' ('+_case+' = '+String(_value)+')', "grey", "incoming");					return;									} else {										return;				}							} else if (_application != appName) {								// if communication came from another app (no need to parse own data)				addToLog('received from: '+_application+' ('+_case+' = '+String(_value)+')', "grey", "incoming");							} 							// filter through test cases			for (var i:int; i < _testCases.length; i++) {								// if application matches				if (_testCases[i][0] == _application || _testCases[i][0] == 'all' || _testCases[i][0] == '*') {										// if name matches					if (_testCases[i][1] == _case || _testCases[i][1] == 'all' || _testCases[i][1] == '*') {																								if (useObjects == false) {							localVars[_case] = utils.stringToObject(_testCases[i][2], _value);			// string mode							dispatchUpdate(_sendTime, _application, _case, localVars[_case]);						} else {							localVars[_case] = _value;													// object mode							dispatchUpdate(_sendTime, _application, _case, _value);						}												addToLog('data matched test case ('+_application+" "+_case+" "+String(_value)+")","important", "incoming");												return;					}				}			}						var _receivedTime:int;			var _update:CommEvent;			var fn:Function;						// filter through requests			for (var j:int; j < _requests.length; j++) {								// if application matches				if (_requests[j][0] == _application || _requests[j][0] == 'all'|| _requests[j][0] == '*') {										// if name matches					if (_requests[j][1] == _case) {												_receivedTime = utils.getTime();												if (useObjects == false) {							localVars[_case] = utils.stringToObject(_requests[i][2], _value);			// string mode							_update = new CommEvent("onRequestedCase", _application, _case, localVars[_case], _sendTime, _receivedTime, true, false);						} else {							localVars[_case] = _value;													// object mode							_update = new CommEvent("onRequestedCase", _application, _case, _value, _sendTime, _receivedTime, true, false);						}												fn = _requests[j][3];						fn(_update);												_requests[j] = null;						_requests.splice(j, 1);												addToLog('data matched request ('+_application+" "+_case+" "+String(_value)+")", "important", "incoming");												return;					}				}			}						// filter through listeners			for (var k:int; k < _listeners.length; k++) {								// if application matches				if (_listeners[k][0] == _application || _listeners[k][0] == 'all' || _listeners[k][0] == '*') {										// if name matches					if (_listeners[k][1] == _case || _listeners[k][1] == 'all' || _listeners[k][1] == '*') {												_receivedTime = utils.getTime();												if (useObjects == false) {							localVars[_case] = utils.stringToObject(_listeners[k][2], _value);			// string mode							_update = new CommEvent("onListenedCase", _application, _case, localVars[_case], _sendTime, _receivedTime, true, false);						} else {							localVars[_case] = _value;													// objecy mode							_update = new CommEvent("onListenedCase", _application, _case, _value, _sendTime, _receivedTime, true, false);						}												fn = _listeners[k][3];						fn(_update);												addToLog('data matched listener ('+_application+" "+_case+" "+String(_value)+")", "important", "incoming");												return;					}				}			}		}				// dispatch local update event (done)		private function dispatchUpdate(_sendTime:int, _application:String, _case:String, _socketData:Object):void {						var _receivedTime:int = utils.getTime();			var _update:CommEvent = new CommEvent("onUpdatedCase", _application, _case, _socketData, _sendTime, _receivedTime, true, false);			dispatchEvent(_update);			//addToLog('received from socket: '+_case, "important", "incoming");			return;		}				/* OTHER STUFF ====== ========= ========== ========== ========== ========== ========== ========== ========== ========== */				/** get the number of connected clients (only usable for server), returned as an int */		public function getClientCount():int {						if (clientSendSockets.length >= clientReceiveSockets.length && _type == 'server') {							return clientSendSockets.length;							} else if (clientReceiveSockets.length > clientSendSockets.length && _type == 'server') {							return clientReceiveSockets.length;						} else {							trace("you're attempting to getClientCount() for a client, this function is only available for the server");				return int(0);			}		}				// update info overlay		private function updateInfo():void {						if (_type == "server") {				widget._infoOverlay.server.value.text = 'SELF';				MovieClip(widget._infoOverlay).outgoing.value.text = _receivePort;				MovieClip(widget._infoOverlay).incoming.value.text = _sendPort;			} else {				widget._infoOverlay.server.value.text = _ip;				MovieClip(widget._infoOverlay).outgoing.value.text = _sendPort;				MovieClip(widget._infoOverlay).incoming.value.text = _receivePort;			}		}				// generate uptime (based on statTime)		private function getUptime(e:Event = null):void {						var _time:int = utils.getTime();						var _upTimeInSec:int = (_time - _startTime) / 1000;						var _days:int = Math.floor(_upTimeInSec / 86400);						_upTimeInSec -= (_days * 86400);			var _hours:String = String(Math.floor(_upTimeInSec / 3600));						if (_hours.length == 1) {    				_hours="0"+_hours; 			} 						_upTimeInSec -= (int(_hours) * 3600);			var _minutes:String = String(Math.floor(_upTimeInSec / 60));						if (_minutes.length == 1) {    				_minutes="0"+_minutes; 			} 						_upTimeInSec -= (int(_minutes) * 60)			var _seconds:String = String(_upTimeInSec);							if (_seconds.length == 1) {    				_seconds="0"+_seconds; 			}						widget._infoOverlay.uptime.value.text = _days+':'+_hours+':'+_minutes+':'+_seconds;			}				// get initial time on connection		private function setStartTime():void {			_startTime = utils.getTime();		}				// shut down server/client before quitting application		private function onExiting(exitingEvent:Event):void {						var winClosingEvent:Event;						if (NativeWindow.isSupported == true) {				for each (var win:NativeWindow in NativeApplication.nativeApplication.openedWindows) {					winClosingEvent = new Event(Event.CLOSING,false,true);					win.dispatchEvent(winClosingEvent);					if (!winClosingEvent.isDefaultPrevented()) {						win.close();					} else {						exitingEvent.preventDefault();					}				}			}						if (!exitingEvent.isDefaultPrevented()) {				addToLog("shutting down...", "grey");								if (_type == "server" && _quitting == false) {					exitingEvent.preventDefault();					_quitting = true;					closeServer();				} else if (_type == "server") {					closeClient();				}			}		}				// get local IP		private function getIp():String{						var netInterfaces:Vector.<NetworkInterface> = NetworkInfo.networkInfo.findInterfaces();			var address:String	= "0.0.0.0";						//Get available interfaces			for (var i:uint = 0; i < netInterfaces.length; i++) {								if (netInterfaces[i].active) {										for (var j:uint = 0; j < netInterfaces[i].addresses.length; j++) {						if (netInterfaces[i].addresses[j].ipVersion == "IPv4") {													address = netInterfaces[i].addresses[j].address;														return address;						}					}				}			}						return address;		} 				// set the _compression method (default is Zlib)		private function set_compression():void {					if (_compressionMethod == 'zlib') {											_compression = CompressionAlgorithm.ZLIB;							} else if (_compressionMethod == 'deflate') {							_compression = CompressionAlgorithm.DEFLATE;							} else {												_compression = null;			}		}				// tombstoning (deactivate)		private function onNativeAppDeactivated(e:Event = null):void {						if (_type == "client" && _suspended == false) {				_suspended = true;				closeClient();			}		}				// tombstoning (activate)		private function onNativeAppActivated(e:Event = null):void {						if (_type == "client" && _suspended == true) {				_suspended = false;				startClient();			}		}				// dispatch a log event so the widget will update its log		private function addToLog(message:String = 'debug', format:String = 'standard', type:String = 'normal'):void {								var _logEvent:LogEvent = new LogEvent('onLog', message, format, type, false, true);			dispatchEvent(_logEvent);		}				/* SINGLETON ====== ========= ========== ========== ========== ========== ========== ========== ========== ========== */				// singleton vars		private static var instance:Sock;		private static var allowInstantiation:Boolean;				// get instance function (singleton) (done)		/** @private */		public static function getInstance():Sock {						if (instance==null) {				allowInstantiation=true;				instance = new Sock();				allowInstantiation=false;			}			return instance;			}				// warning to use as singleton (done)		/** @private */		public function Sock():void {						if (! allowInstantiation) {				throw new Error("ERROR: Use Sock.getInstance() instead of new.");			}		}		}}